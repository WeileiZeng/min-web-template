<!DOCTYPE html><html>
<head>
<title>Note on Belief Propagation</title>
<!--Generated on Thu Apr 16 20:40:13 2020 by LaTeXML (version 0.8.4) http://dlmf.nist.gov/LaTeXML/.-->
<!--Document created on April 16, 2020.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">Note on Belief Propagation</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Weilei Zeng
</span></span>
</div>
<div class="ltx_date ltx_role_creation">April 16, 2020</div>

<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract</h6>
    
<p class="ltx_p">This work gives a detail description of Belief Propagation (BP)
algorithm and several of its variations.</p>
  
</div>
<section id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">I </span>description of binary BP decoder</h2>

<div id="S1.p1" class="ltx_para">
<p class="ltx_p">The Belief Propagation (BP) algorithm can approximate the maginal
probability of errors, giving the received bits or the syndrome. It is
designed for factor graph. When the graph is a tree, it gives the
exact marginal probability. There are several equivalent/approximate
versions of it, let us start with the classical one.</p>
</div>
<section id="S1.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">I.1 </span>codeword-based</h3>

<div id="S1.SS1.p1" class="ltx_para">
<p class="ltx_p">BP decoder for classical binary codes:</p>
</div>
<div id="S1.SS1.p2" class="ltx_para">
<p class="ltx_p">A code is defined by a factor graph ( with assumed degree <math id="S1.SS1.p2.m1" class="ltx_Math" alttext="d+1" display="inline"><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></math> and) with variable nodes <math id="S1.SS1.p2.m2" class="ltx_Math" alttext="V=\{c_{i}\}" display="inline"><mrow><mi>V</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow></mrow></math>
and check nodes <math id="S1.SS1.p2.m3" class="ltx_Math" alttext="C=\{c_{i}\}" display="inline"><mrow><mi>C</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow></mrow></math>. The message from variable to check is</p>
<table id="S1.Ex1" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex1.m1" class="ltx_Math" alttext="u_{v-c}(x)=m(x)=P(y_{v}|x)\prod_{j=1..d}M_{j}(x)\text{, where }\{c_{1},...,c_{%
d}\}=N(v)\setminus c,~{}x\in\{0,~{}1\}" display="block"><mrow><mrow><mrow><msub><mi>u</mi><mrow><mi>v</mi><mo>-</mo><mi>c</mi></mrow></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>m</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>P</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>y</mi><mi>v</mi></msub><mo lspace="2.5pt" rspace="2.5pt" stretchy="false">|</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow><mo>‚Å¢</mo><mrow><munder><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>.</mo><mo>.</mo><mi>d</mi></mrow></munder><mrow><msub><mi>M</mi><mi>j</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>‚Å¢</mo><mtext>, where¬†</mtext><mo>‚Å¢</mo><mrow><mo stretchy="false">{</mo><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">‚Ä¶</mi><mo>,</mo><msub><mi>c</mi><mi>d</mi></msub><mo stretchy="false">}</mo></mrow></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mi>N</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><mo>‚àñ</mo><mi>c</mi></mrow></mrow><mo rspace="5.8pt">,</mo><mrow><mi>x</mi><mo>‚àà</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo rspace="5.8pt">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">The message from check to variable is</p>
<table id="S1.Ex2" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex2.m1" class="ltx_Math" alttext="u_{c-v}=M(x)=\sum_{x_{1},...,x_{d}}\delta({\bf h}_{c}{\bf x}^{T}=0)\prod_{j=1}%
^{d}m_{j}(x)\text{, where}\{v_{1},...,v_{d}\}=N(c)\setminus v" display="block"><mrow><msub><mi>u</mi><mrow><mi>c</mi><mo>-</mo><mi>v</mi></mrow></msub><mo>=</mo><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><munder><mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">‚Ä¶</mi><mo>,</mo><msub><mi>x</mi><mi>d</mi></msub></mrow></munder><mi>Œ¥</mi><mrow><mo stretchy="false">(</mo><msub><mi>ùê°</mi><mi>c</mi></msub><msup><mi>ùê±</mi><mi>T</mi></msup><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><msub><mi>m</mi><mi>j</mi></msub><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mtext>, where</mtext><mrow><mo stretchy="false">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">‚Ä¶</mi><mo>,</mo><msub><mi>v</mi><mi>d</mi></msub><mo stretchy="false">}</mo></mrow><mo>=</mo><mi>N</mi><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><mo>‚àñ</mo><mi>v</mi></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">The initial condition is <math id="S1.SS1.p2.m4" class="ltx_Math" alttext="M_{j}(x)=1,x\in\{0,1\}" display="inline"><mrow><mrow><mrow><msub><mi>M</mi><mi>j</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow><mo>,</mo><mrow><mi>x</mi><mo>‚àà</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow></mrow></mrow></math>.</p>
</div>
<div id="S1.SS1.p3" class="ltx_para">
<p class="ltx_p">(To generalize it to nonbinary case, one only need to modify the
parity check condition from matrix miltiplication to symplectic
product. Everything else will be extended smoothly)</p>
</div>
</section>
<section id="S1.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">I.2 </span>codeword-based, LLR-simplified</h3>

<div id="S1.SS2.p1" class="ltx_para">
<p class="ltx_p">By rewriting the probabilities and messages in terms of the
log-likelihood ratio</p>
</div>
<div id="S1.SS2.p2" class="ltx_para">
<p class="ltx_p"><math id="S1.SS2.p2.m1" class="ltx_Math" alttext="l_{i}=\log(m_{i}(0)/m_{i}(1))" display="inline"><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mrow><mi>log</mi><mo>‚Å°</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>/</mo><msub><mi>m</mi><mi>i</mi></msub></mrow><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, <math id="S1.SS2.p2.m2" class="ltx_Math" alttext="M_{i}=\log(M_{i}(0)/M_{i}(1))" display="inline"><mrow><msub><mi>M</mi><mi>i</mi></msub><mo>=</mo><mrow><mi>log</mi><mo>‚Å°</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><msub><mi>M</mi><mi>i</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>/</mo><msub><mi>M</mi><mi>i</mi></msub></mrow><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, one can get the simplified message:</p>
</div>
<div id="S1.SS2.p3" class="ltx_para">
<table id="S1.Ex3" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex3.m1" class="ltx_Math" alttext="l_{i}=l_{i}^{(0)}+\sum_{j=1}^{d}(L_{j})" display="block"><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mrow><msubsup><mi>l</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><mrow><mo stretchy="false">(</mo><msub><mi>L</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS2.p4" class="ltx_para">
<table id="S1.Ex4" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex4.m1" class="ltx_Math" alttext="L_{i}=2\tanh^{-1}\prod_{j=1}^{d}\tanh(l_{j}/2)" display="block"><mrow><msub><mi>L</mi><mi>i</mi></msub><mo>=</mo><mrow><mn>2</mn><mo>‚Å¢</mo><msup><mi>tanh</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>‚Å¢</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><mrow><mi>tanh</mi><mo>‚Å°</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>l</mi><mi>j</mi></msub><mo>/</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS2.p5" class="ltx_para">
<table id="S1.Ex5" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex5.m1" class="ltx_Math" alttext="l^{(0)}_{i}=\log(P(x_{i}=0|y_{i})/P(x_{i}=1)|y_{i}),~{}y_{i}\in\{0,1\}" display="block"><mrow><msubsup><mi>l</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi>log</mi><mrow><mo stretchy="false">(</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mo stretchy="false">|</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mo>/</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">|</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mo rspace="5.8pt">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>‚àà</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">,</p>
</div>
<div id="S1.SS2.p6" class="ltx_para">
<p class="ltx_p">When <math id="S1.SS2.p6.m1" class="ltx_Math" alttext="y_{i}=0\text{ or }1" display="inline"><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mrow><mn>0</mn><mo>‚Å¢</mo><mtext>¬†or¬†</mtext><mo>‚Å¢</mo><mn>1</mn></mrow></mrow></math>, <math id="S1.SS2.p6.m2" class="ltx_Math" alttext="l_{i}^{(0)}" display="inline"><msubsup><mi>l</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math> will be flipped.
</p>
</div>
<div id="S1.SS2.p7" class="ltx_para">
<p class="ltx_p">In this simplified form, only one message need to be sent per edge,
instead of two messages for 0 and 1 respectively. Hence, the
complexity is reduced.</p>
</div>
</section>
<section id="S1.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">I.3 </span>syndrome-based</h3>

<div id="S1.SS3.p1" class="ltx_para">
<p class="ltx_p">In classical case, the received bits was used, instead of the
syndrome. In quantum case, there are no received bits, but only the
syndrome.
Hence, to get the formula in quantum case, one need to
change it to a syndrome-based decoder.</p>
</div>
<div id="S1.SS3.p2" class="ltx_para">
<p class="ltx_p">Ref <cite class="ltx_cite ltx_citemacro_cite">(MacKay and Mac Kay, <a href="#bib.bib8" title="Information theory, inference and learning algorithms" class="ltx_ref">2003</a>, chapter¬†47.2)</cite> show that the
codeword-based BP decoder is equivalent to the following
syndrome-based decoder</p>
</div>
<div id="S1.SS3.p3" class="ltx_para">
<table id="S1.Ex6" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex6.m1" class="ltx_Math" alttext="u_{v-c}(x)=m(x)=P(x)\prod_{j=1..d}M_{j}(x)\text{, where }\{c_{1},...,c_{d}\}=N%
(v)\setminus c" display="block"><mrow><mrow><msub><mi>u</mi><mrow><mi>v</mi><mo>-</mo><mi>c</mi></mrow></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>m</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>P</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>‚Å¢</mo><mrow><munder><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>.</mo><mo>.</mo><mi>d</mi></mrow></munder><mrow><msub><mi>M</mi><mi>j</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>‚Å¢</mo><mtext>, where¬†</mtext><mo>‚Å¢</mo><mrow><mo stretchy="false">{</mo><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">‚Ä¶</mi><mo>,</mo><msub><mi>c</mi><mi>d</mi></msub><mo stretchy="false">}</mo></mrow></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mi>N</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><mo>‚àñ</mo><mi>c</mi></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS3.p4" class="ltx_para">
<table id="S1.Ex7" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex7.m1" class="ltx_Math" alttext="u_{c-v}=M(x)=\sum_{x_{1},...,x_{d}}\delta({\bf h}_{c}{\bf x}^{T}={\bf s}^{T})%
\prod_{j=1}^{d}m_{j}(x)\text{, where}\{v_{1},...,v_{d}\}=N(c)\setminus v" display="block"><mrow><msub><mi>u</mi><mrow><mi>c</mi><mo>-</mo><mi>v</mi></mrow></msub><mo>=</mo><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><munder><mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">‚Ä¶</mi><mo>,</mo><msub><mi>x</mi><mi>d</mi></msub></mrow></munder><mi>Œ¥</mi><mrow><mo stretchy="false">(</mo><msub><mi>ùê°</mi><mi>c</mi></msub><msup><mi>ùê±</mi><mi>T</mi></msup><mo>=</mo><msup><mi>ùê¨</mi><mi>T</mi></msup><mo stretchy="false">)</mo></mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><msub><mi>m</mi><mi>j</mi></msub><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mtext>, where</mtext><mrow><mo stretchy="false">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">‚Ä¶</mi><mo>,</mo><msub><mi>v</mi><mi>d</mi></msub><mo stretchy="false">}</mo></mrow><mo>=</mo><mi>N</mi><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><mo>‚àñ</mo><mi>v</mi></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">The initial condition is still <math id="S1.SS3.p4.m1" class="ltx_Math" alttext="M_{j}(x)=1,x\in\{0,1\}" display="inline"><mrow><mrow><mrow><msub><mi>M</mi><mi>j</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow><mo>,</mo><mrow><mi>x</mi><mo>‚àà</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow></mrow></mrow></math>.</p>
</div>
<div id="S1.SS3.p5" class="ltx_para">
<p class="ltx_p">The logic is that, the codeword-view calculate <math id="S1.SS3.p5.m1" class="ltx_Math" alttext="P(x|y)" display="inline"><mrow><mi>P</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo lspace="2.5pt" rspace="2.5pt" stretchy="false">|</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math> (the
most-likely input codeword <math id="S1.SS3.p5.m2" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> given the recieved vector <math id="S1.SS3.p5.m3" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math>) and the
syndrome-view calculate <math id="S1.SS3.p5.m4" class="ltx_Math" alttext="P(e|s)" display="inline"><mrow><mi>P</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>e</mi><mo lspace="2.5pt" rspace="2.5pt" stretchy="false">|</mo><mi>s</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math> (the most-likely error <math id="S1.SS3.p5.m5" class="ltx_Math" alttext="e" display="inline"><mi>e</mi></math> given this
syndrome <math id="S1.SS3.p5.m6" class="ltx_Math" alttext="s" display="inline"><mi>s</mi></math>). Here <math id="S1.SS3.p5.m7" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> should be an valid zero-syndrome
input codeword; <math id="S1.SS3.p5.m8" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> is the received vector; and <math id="S1.SS3.p5.m9" class="ltx_Math" alttext="e" display="inline"><mi>e</mi></math> is an error vector
matching syndrome <math id="S1.SS3.p5.m10" class="ltx_Math" alttext="s" display="inline"><mi>s</mi></math>. Literally, these two marginal probability are
describing the same event, thus should lead to the same
result. Mathematically, one has to write it carefully and show they
are isomorphic.</p>
</div>
</section>
<section id="S1.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">I.4 </span>syndrome-based, LLR simplified</h3>

<div id="S1.SS4.p1" class="ltx_para">
<p class="ltx_p">In a similar fashion of simplification, one can write the above
equations into the log-likelihood-ratio form, then reach the following
simple formula <cite class="ltx_cite ltx_citemacro_cite">Liu and Poulin (<a href="#bib.bib26" title="Neural belief-propagation decoders for quantum error-correcting codes" class="ltx_ref">2018</a>)</cite></p>
</div>
<div id="S1.SS4.p2" class="ltx_para">
<table id="S1.Ex8" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex8.m1" class="ltx_Math" alttext="l_{i}=l_{i}^{(0)}+\sum_{j=1}^{d}(L_{j})" display="block"><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mrow><msubsup><mi>l</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><mrow><mo stretchy="false">(</mo><msub><mi>L</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS4.p3" class="ltx_para">
<table id="S1.Ex9" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex9.m1" class="ltx_Math" alttext="L_{i}=(-1)^{s_{i}}2\tanh^{-1}\prod_{j=1}^{d}\tanh(l_{j}/2)" display="block"><mrow><msub><mi>L</mi><mi>i</mi></msub><mo>=</mo><mrow><msup><mrow><mo stretchy="false">(</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><msub><mi>s</mi><mi>i</mi></msub></msup><mo>‚Å¢</mo><mn>2</mn><mo>‚Å¢</mo><msup><mi>tanh</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>‚Å¢</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><mrow><mi>tanh</mi><mo>‚Å°</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>l</mi><mi>j</mi></msub><mo>/</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS4.p4" class="ltx_para">
<table id="S1.Ex10" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex10.m1" class="ltx_Math" alttext="l_{i}^{(0)}=\log(P(x_{i}=0)/P(x_{i}=1))=\text{const}" display="block"><mrow><msubsup><mi>l</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi>log</mi><mrow><mo stretchy="false">(</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mo>/</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo>=</mo><mtext>const</mtext></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS4.p5" class="ltx_para">
<p class="ltx_p">The posterior log-likelihood ratio can be estimated as
<math id="S1.SS4.p5.m1" class="ltx_Math" alttext="l_{i}=l_{i}^{(0)}+\sum_{j=1}^{d+1}(L_{j})" display="inline"><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mrow><msubsup><mi>l</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mrow><msubsup><mo largeop="true" symmetric="true">‚àë</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="false">(</mo><msub><mi>L</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></p>
</div>
<div id="S1.SS4.p6" class="ltx_para">
<p class="ltx_p">This syndrome-based BP decoder can be used for quantum code as
well. We first discuss the case of CSS codes, then the case of GF(4)
codes.</p>
</div>
</section>
<section id="S1.SS5" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">I.5 </span>discussion on quantum case</h3>

<div id="S1.SS5.p1" class="ltx_para">
<p class="ltx_p">In CSS codes, one has <math id="S1.SS5.p1.m1" class="ltx_Math" alttext="GH^{T}=0" display="inline"><mrow><mrow><mi>G</mi><mo>‚Å¢</mo><msup><mi>H</mi><mi>T</mi></msup></mrow><mo>=</mo><mn>0</mn></mrow></math>. Say <math id="S1.SS5.p1.m2" class="ltx_Math" alttext="H" display="inline"><mi>H</mi></math> is the parity check matrix,
then the only difference from a classical code with parity check
matrix <math id="S1.SS5.p1.m3" class="ltx_Math" alttext="H" display="inline"><mi>H</mi></math> is that one need to check the decoded vector is an trivial
error or not, that is, if it can be eliminated
by rows of <math id="S1.SS5.p1.m4" class="ltx_Math" alttext="G" display="inline"><mi>G</mi></math> or not. Hence, the CSS code can use BP decoder directly
with a post check.</p>
</div>
<div id="S1.SS5.p2" class="ltx_para">
<p class="ltx_p">In GF(4) code, the generator matrix <math id="S1.SS5.p2.m1" class="ltx_Math" alttext="G=(A|B)" display="inline"><mrow><mi>G</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo lspace="2.5pt" rspace="2.5pt" stretchy="false">|</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math> satisfies <math id="S1.SS5.p2.m2" class="ltx_Math" alttext="G\tilde{G}^{T}=AB^{T}+BA^{T}=0" display="inline"><mrow><mrow><mi>G</mi><mo>‚Å¢</mo><msup><mover accent="true"><mi>G</mi><mo stretchy="false">~</mo></mover><mi>T</mi></msup></mrow><mo>=</mo><mrow><mrow><mi>A</mi><mo>‚Å¢</mo><msup><mi>B</mi><mi>T</mi></msup></mrow><mo>+</mo><mrow><mi>B</mi><mo>‚Å¢</mo><msup><mi>A</mi><mi>T</mi></msup></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>, where <math id="S1.SS5.p2.m3" class="ltx_Math" alttext="\tilde{G}=(B|A)" display="inline"><mrow><mover accent="true"><mi>G</mi><mo stretchy="false">~</mo></mover><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>B</mi><mo lspace="2.5pt" rspace="2.5pt" stretchy="false">|</mo><mi>A</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>. Here, one can just decode a
classical code with parity check matrix <math id="S1.SS5.p2.m4" class="ltx_Math" alttext="\tilde{G}" display="inline"><mover accent="true"><mi>G</mi><mo stretchy="false">~</mo></mover></math>, then check if it
is a combination of rows of <math id="S1.SS5.p2.m5" class="ltx_Math" alttext="G" display="inline"><mi>G</mi></math>.</p>
</div>
<div id="S1.SS5.p3" class="ltx_para">
<p class="ltx_p">Note that, in both CSS codes and GF(4) codes, the correlation between
X and Z errors are not considered. One way to consider the
correlations is as following.</p>
</div>
<div id="S1.SS5.p4" class="ltx_para">
<p class="ltx_p">One can change the
generator matrix from</p>
<table id="S1.Ex11" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex11.m1" class="ltx_Math" alttext="G=(A|B),H=(B|A)" display="block"><mrow><mrow><mi>G</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo lspace="2.5pt" rspace="2.5pt" stretchy="false">|</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>H</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>B</mi><mo lspace="2.5pt" rspace="2.5pt" stretchy="false">|</mo><mi>A</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">to</p>
<table id="S1.Ex12" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex12.m1" class="ltx_Math" alttext="\tilde{G}=G\left(\begin{array}[]{ccc}I&amp;&amp;I\\
&amp;I&amp;I\end{array}\right)=(A|B|A+B),\tilde{H}=\left(\begin{array}[]{ccc}B&amp;A\\
I&amp;I&amp;I\end{array}\right)" display="block"><mrow><mrow><mover accent="true"><mi>G</mi><mo stretchy="false">~</mo></mover><mo>=</mo><mrow><mi>G</mi><mo>‚Å¢</mo><mrow><mo>(</mo><mtable columnspacing="5pt" displaystyle="true" rowspacing="0pt"><mtr><mtd columnalign="center"><mi>I</mi></mtd><mtd></mtd><mtd columnalign="center"><mi>I</mi></mtd></mtr><mtr><mtd></mtd><mtd columnalign="center"><mi>I</mi></mtd><mtd columnalign="center"><mi>I</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>A</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow><mo>‚Å¢</mo><mi>A</mi></mrow><mo>+</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mover accent="true"><mi>H</mi><mo stretchy="false">~</mo></mover><mo>=</mo><mrow><mo>(</mo><mtable columnspacing="5pt" displaystyle="true" rowspacing="0pt"><mtr><mtd columnalign="center"><mi>B</mi></mtd><mtd columnalign="center"><mi>A</mi></mtd><mtd></mtd></mtr><mtr><mtd columnalign="center"><mi>I</mi></mtd><mtd columnalign="center"><mi>I</mi></mtd><mtd columnalign="center"><mi>I</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">The error changes from <math id="S1.SS5.p4.m1" class="ltx_Math" alttext="(e_{X}|e_{Z})" display="inline"><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mi>X</mi></msub><mo lspace="2.5pt" rspace="2.5pt" stretchy="false">|</mo><msub><mi>e</mi><mi>Z</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math> to <math id="S1.SS5.p4.m2" class="ltx_Math" alttext="(e_{X}|e_{Z}|e_{Y})" display="inline"><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mi>X</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">|</mo><msub><mi>e</mi><mi>Z</mi></msub><mo stretchy="false">|</mo></mrow><mo>‚Å¢</mo><msub><mi>e</mi><mi>Y</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>, which satisfy
<math id="S1.SS5.p4.m3" class="ltx_Math" alttext="(I|I|I)(e_{X}|e_{Z}|e_{Y})^{T}=0" display="inline"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>I</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">|</mo><mi>I</mi><mo stretchy="false">|</mo></mrow><mo>‚Å¢</mo><mi>I</mi></mrow><mo stretchy="false">)</mo></mrow><mo>‚Å¢</mo><msup><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mi>X</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">|</mo><msub><mi>e</mi><mi>Z</mi></msub><mo stretchy="false">|</mo></mrow><mo>‚Å¢</mo><msub><mi>e</mi><mi>Y</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mi>T</mi></msup></mrow><mo>=</mo><mn>0</mn></mrow></math>. (Any single error will produce an
even number of 1s in the vector. This <math id="S1.SS5.p4.m4" class="ltx_Math" alttext="e_{Y}" display="inline"><msub><mi>e</mi><mi>Y</mi></msub></math> is not the Pauli Y error,
but simply a superposition of X and Z, <math id="S1.SS5.p4.m5" class="ltx_Math" alttext="e_{Y}=e_{X}+e_{Z}" display="inline"><mrow><msub><mi>e</mi><mi>Y</mi></msub><mo>=</mo><mrow><msub><mi>e</mi><mi>X</mi></msub><mo>+</mo><msub><mi>e</mi><mi>Z</mi></msub></mrow></mrow></math> mod 2.) This
extra Y node contain the information that X and Z errors tend to
appear or disapear in pair but not alone.</p>
</div>
<div id="S1.SS5.p5" class="ltx_para">
<p class="ltx_p">In this construction, we can just take the new parity check matrix as
a classical binary code and use the basic BP decoder.</p>
</div>
</section>
<section id="S1.SS6" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">I.6 </span>variation of BP</h3>

<section id="S1.SS6.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">I.6.1 </span>Min-Sum</h4>

<div id="S1.SS6.SSS1.p1" class="ltx_para">
<p class="ltx_p">Finally, there are some optimization of BP decoder, including
normalized and offset min-sum
decoder <cite class="ltx_cite ltx_citemacro_cite">Chen<span class="ltx_text ltx_bib_etal"> et al.</span> (<a href="#bib.bib5" title="Improved min-sum decoding algorithms for irregular ldpc codes" class="ltx_ref">2005</a>)</cite>. Ref¬†<cite class="ltx_cite ltx_citemacro_cite">Panteleev and Kalachev (<a href="#bib.bib7" title="Degenerate quantum ldpc codes with good finite length performance" class="ltx_ref">2019</a>)</cite> says they are always using
normalized offset min-sum decoder with mormalization factor <math id="S1.SS6.SSS1.p1.m1" class="ltx_Math" alttext="\alpha=0.625" display="inline"><mrow><mi>Œ±</mi><mo>=</mo><mn>0.625</mn></mrow></math>.</p>
</div>
<div id="S1.SS6.SSS1.p2" class="ltx_para">
<p class="ltx_p">Here I use <math id="S1.SS6.SSS1.p2.m1" class="ltx_Math" alttext="L^{BP},~{}L^{MS},~{}L^{NORM},~{}L^{OFF}" display="inline"><mrow><msup><mi>L</mi><mrow><mi>B</mi><mo>‚Å¢</mo><mi>P</mi></mrow></msup><mo rspace="5.8pt">,</mo><msup><mi>L</mi><mrow><mi>M</mi><mo>‚Å¢</mo><mi>S</mi></mrow></msup><mo rspace="5.8pt">,</mo><msup><mi>L</mi><mrow><mi>N</mi><mo>‚Å¢</mo><mi>O</mi><mo>‚Å¢</mo><mi>R</mi><mo>‚Å¢</mo><mi>M</mi></mrow></msup><mo rspace="5.8pt">,</mo><msup><mi>L</mi><mrow><mi>O</mi><mo>‚Å¢</mo><mi>F</mi><mo>‚Å¢</mo><mi>F</mi></mrow></msup></mrow></math> to denote the
check-to-variable messages
for BP, min-sum,
normalized min-sum, and off-set min-sum respectively. The relation on
their sign and magnitute are</p>
</div>
<div id="S1.SS6.SSS1.p3" class="ltx_para">
<table id="S1.Ex13" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex13.m1" class="ltx_Math" alttext="\mathop{\rm sgn}(L^{BP})=\mathop{\rm sgn}(L^{MS})=(-1)^{s_{c}}\prod_{i}^{d}%
\mathop{\rm sgn}(l_{j})" display="block"><mrow><mrow><mo movablelimits="false">sgn</mo><mrow><mo stretchy="false">(</mo><msup><mi>L</mi><mrow><mi>B</mi><mo>‚Å¢</mo><mi>P</mi></mrow></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo movablelimits="false">sgn</mo><mrow><mo stretchy="false">(</mo><msup><mi>L</mi><mrow><mi>M</mi><mo>‚Å¢</mo><mi>S</mi></mrow></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mrow><mo stretchy="false">(</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><msub><mi>s</mi><mi>c</mi></msub></msup><mo>‚Å¢</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mi>i</mi><mi>d</mi></munderover><mrow><mo movablelimits="false">sgn</mo><mrow><mo stretchy="false">(</mo><msub><mi>l</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS6.SSS1.p4" class="ltx_para">
<table id="S1.Ex14" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex14.m1" class="ltx_Math" alttext="|L_{i}^{BP}|=2\tanh^{-1}\prod_{j=1}^{d}\tanh(|l_{j}|/2)" display="block"><mrow><mrow><mo stretchy="false">|</mo><msubsup><mi>L</mi><mi>i</mi><mrow><mi>B</mi><mo>‚Å¢</mo><mi>P</mi></mrow></msubsup><mo stretchy="false">|</mo></mrow><mo>=</mo><mrow><mn>2</mn><mo>‚Å¢</mo><msup><mi>tanh</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>‚Å¢</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><mrow><mi>tanh</mi><mo>‚Å°</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">|</mo><msub><mi>l</mi><mi>j</mi></msub><mo stretchy="false">|</mo></mrow><mo>/</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS6.SSS1.p5" class="ltx_para">
<table id="S1.Ex15" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex15.m1" class="ltx_Math" alttext="|L_{i}^{MS}|=\min_{i}^{d}|l_{j}|" display="block"><mrow><mrow><mo stretchy="false">|</mo><msubsup><mi>L</mi><mi>i</mi><mrow><mi>M</mi><mo>‚Å¢</mo><mi>S</mi></mrow></msubsup><mo stretchy="false">|</mo></mrow><mo>=</mo><mrow><munderover><mi>min</mi><mi>i</mi><mi>d</mi></munderover><mo>‚Å°</mo><mrow><mo stretchy="false">|</mo><msub><mi>l</mi><mi>j</mi></msub><mo stretchy="false">|</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS6.SSS1.p6" class="ltx_para">
<table id="S1.Ex16" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex16.m1" class="ltx_Math" alttext="|L_{i}^{NORM}|=\min_{i}^{d}|l_{j}|/\alpha,~{}\alpha&gt;1" display="block"><mrow><mrow><mrow><mo stretchy="false">|</mo><msubsup><mi>L</mi><mi>i</mi><mrow><mi>N</mi><mo>‚Å¢</mo><mi>O</mi><mo>‚Å¢</mo><mi>R</mi><mo>‚Å¢</mo><mi>M</mi></mrow></msubsup><mo stretchy="false">|</mo></mrow><mo>=</mo><mrow><munderover><mi>min</mi><mi>i</mi><mi>d</mi></munderover><mo>‚Å°</mo><mrow><mrow><mo stretchy="false">|</mo><msub><mi>l</mi><mi>j</mi></msub><mo stretchy="false">|</mo></mrow><mo>/</mo><mi>Œ±</mi></mrow></mrow></mrow><mo rspace="5.8pt">,</mo><mrow><mi>Œ±</mi><mo>&gt;</mo><mn>1</mn></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S1.SS6.SSS1.p7" class="ltx_para">
<table id="S1.Ex17" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex17.m1" class="ltx_Math" alttext="|L_{i}^{OFF}|=\max(\min_{i}^{d}|l_{j}|-\beta,0),~{}\beta&gt;0" display="block"><mrow><mrow><mrow><mo stretchy="false">|</mo><msubsup><mi>L</mi><mi>i</mi><mrow><mi>O</mi><mo>‚Å¢</mo><mi>F</mi><mo>‚Å¢</mo><mi>F</mi></mrow></msubsup><mo stretchy="false">|</mo></mrow><mo>=</mo><mrow><mi>max</mi><mo>‚Å°</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munderover><mi>min</mi><mi>i</mi><mi>d</mi></munderover><mo>‚Å°</mo><mrow><mo stretchy="false">|</mo><msub><mi>l</mi><mi>j</mi></msub><mo stretchy="false">|</mo></mrow></mrow><mo>-</mo><mi>Œ≤</mi></mrow><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo rspace="5.8pt">,</mo><mrow><mi>Œ≤</mi><mo>&gt;</mo><mn>0</mn></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
</section>
<section id="S1.SS6.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">I.6.2 </span>layered scheduling for updating rule</h4>

<div id="S1.SS6.SSS2.p1" class="ltx_para">
<p class="ltx_p">Ref <cite class="ltx_cite ltx_citemacro_cite">Panteleev and Kalachev (<a href="#bib.bib7" title="Degenerate quantum ldpc codes with good finite length performance" class="ltx_ref">2019</a>)</cite> claim they used layered scheduling,
which helped to eliminate the oscillating errors caused by the
trapping sets.
The criteria for how to choose the schedule is unclear for me yet.</p>
</div>
</section>
<section id="S1.SS6.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">I.6.3 </span>enhanced feedback</h4>

<div id="S1.SS6.SSS3.p1" class="ltx_para">
<p class="ltx_p">Ref <cite class="ltx_cite ltx_citemacro_cite">Wang<span class="ltx_text ltx_bib_etal"> et al.</span> (<a href="#bib.bib4" title="Enhanced feedback iterative decoding of sparse quantum codes" class="ltx_ref">2012</a>)</cite> developed an optimization called Enhanced
Feedback iterative BP decoder. In the second round of BP decoding, he
locate the frustrated checks and some common qubits connected with
them, then use the output probability to replace the input probability
for those qubits. This approach is very similar to what I tried ( in
the codeword-based LLR-simplified BP decoder for toric codes). The
difference is that, I simply use the output probability (LLR vector)
to replace the input probability for all qubits. I saw it fix all double errors
on large-size (about 35x35) toric codes, but only tiny improvement in
the numerics of small size (5, 7, 9, 11, 13). I am not sure about the
reason on small size. there may be a bug in the program as well.</p>
</div>
</section>
</section>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul id="bib.L1" class="ltx_biblist">
<li id="bib.bib5" class="ltx_bibitem ltx_bib_inproceedings">
<span class="ltx_tag ltx_bib_key ltx_role_refnum ltx_tag_bibitem">[1]</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_author">J. Chen, R. M. Tanner, C. Jones, and Y. Li</span><span class="ltx_text ltx_bib_year"> (2005)</span>
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Improved min-sum decoding algorithms for irregular ldpc codes</span>.
</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_bib_inbook">Proceedings. International Symposium on Information Theory, 2005. ISIT 2005.</span>,
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_pages"> pp.¬†449‚Äì453</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S1.SS6.SSS1.p1" title="I.6.1 Min-Sum ‚Ä£ I.6 variation of BP ‚Ä£ I description of binary BP decoder ‚Ä£ Note on Belief Propagation" class="ltx_ref"><span class="ltx_text ltx_ref_tag">¬ßI.6.1</span></a>.
</span>
</li>
<li id="bib.bib26" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_key ltx_role_refnum ltx_tag_bibitem">[2]</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_author">Y. Liu and D. Poulin</span><span class="ltx_text ltx_bib_year"> (2018)</span>
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Neural belief-propagation decoders for quantum error-correcting codes</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">arXiv preprint arXiv:1811.07835</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S1.SS4.p1" title="I.4 syndrome-based, LLR simplified ‚Ä£ I description of binary BP decoder ‚Ä£ Note on Belief Propagation" class="ltx_ref"><span class="ltx_text ltx_ref_tag">¬ßI.4</span></a>.
</span>
</li>
<li id="bib.bib8" class="ltx_bibitem ltx_bib_book">
<span class="ltx_tag ltx_bib_key ltx_role_refnum ltx_tag_bibitem">[3]</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_author">D. J. MacKay and D. J. Mac Kay</span><span class="ltx_text ltx_bib_year"> (2003)</span>
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Information theory, inference and learning algorithms</span>.
</span>
<span class="ltx_bibblock"> <span class="ltx_text ltx_bib_publisher">Cambridge university press</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S1.SS3.p2" title="I.3 syndrome-based ‚Ä£ I description of binary BP decoder ‚Ä£ Note on Belief Propagation" class="ltx_ref"><span class="ltx_text ltx_ref_tag">¬ßI.3</span></a>.
</span>
</li>
<li id="bib.bib7" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_key ltx_role_refnum ltx_tag_bibitem">[4]</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_author">P. Panteleev and G. Kalachev</span><span class="ltx_text ltx_bib_year"> (2019)</span>
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Degenerate quantum ldpc codes with good finite length performance</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">arXiv preprint arXiv:1904.02703</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S1.SS6.SSS1.p1" title="I.6.1 Min-Sum ‚Ä£ I.6 variation of BP ‚Ä£ I description of binary BP decoder ‚Ä£ Note on Belief Propagation" class="ltx_ref"><span class="ltx_text ltx_ref_tag">¬ßI.6.1</span></a>,
<a href="#S1.SS6.SSS2.p1" title="I.6.2 layered scheduling for updating rule ‚Ä£ I.6 variation of BP ‚Ä£ I description of binary BP decoder ‚Ä£ Note on Belief Propagation" class="ltx_ref"><span class="ltx_text ltx_ref_tag">¬ßI.6.2</span></a>.
</span>
</li>
<li id="bib.bib4" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_key ltx_role_refnum ltx_tag_bibitem">[5]</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_author">Y. Wang, B. C. Sanders, B. Bai, and X. Wang</span><span class="ltx_text ltx_bib_year"> (2012)</span>
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Enhanced feedback iterative decoding of sparse quantum codes</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">IEEE Transactions on Information Theory</span> <span class="ltx_text ltx_bib_volume">58</span> (<span class="ltx_text ltx_bib_number">2</span>), <span class="ltx_text ltx_bib_pages"> pp.¬†1231‚Äì1241</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S1.SS6.SSS3.p1" title="I.6.3 enhanced feedback ‚Ä£ I.6 variation of BP ‚Ä£ I description of binary BP decoder ‚Ä£ Note on Belief Propagation" class="ltx_ref"><span class="ltx_text ltx_ref_tag">¬ßI.6.3</span></a>.
</span>
</li>
</ul>
</section>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Thu Apr 16 20:40:13 2020 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
